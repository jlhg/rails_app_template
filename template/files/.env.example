# Docker Compose Environment Variables
# Copy this file to .env and adjust values as needed
# All variables have defaults in compose.yaml - override here if needed
#
# IMPORTANT: This configuration is for production-like environments.
# The Docker image only includes production gems (no development/test gems).
# Suitable for: production, staging, demo
# NOT suitable for: development, test (use compose.local.yaml instead)

# ============================================================================
# Build Configuration
# ============================================================================

# GitLab Configuration (for private repositories)
# Set this to your self-hosted GitLab instance URL
# Default: gitlab.com (official GitLab)
# Example for self-hosted: git.mycompany.com
GITLAB_HOST=gitlab.com

# ============================================================================
# Rails Configuration
# ============================================================================

# Rails environment (default: production)
# Supported: production, staging (Docker image only includes production gems)
# NOT recommended: development, test (missing dev/test gems)
# RAILS_ENV=production

# Enable Ruby YJIT for 15-30% performance boost (default: 1)
# RUBY_YJIT_ENABLE=1

# Ruby options (default: --enable-frozen-string-literal)
# Makes all string literals frozen by default for better performance and memory usage
# Note: This is set by default in Dockerfile and compose.yaml
# RUBYOPT=--enable-frozen-string-literal

# ============================================================================
# Puma Web Server Configuration
# ============================================================================

# Number of worker processes (default: 2)
# Recommended: Set to number of CPU cores
# Example: 2 workers × 16 threads = 32 concurrent requests
# Single mode (no workers): WEB_CONCURRENCY=0
# WEB_CONCURRENCY=2

# Number of threads per worker (default: 16)
# Range: 8-32 for applications with WebSocket support
# Higher values = more concurrent connections (including WebSocket), more memory usage
# RAILS_MAX_THREADS=16
# RAILS_MIN_THREADS=16

# Worker timeout in seconds (default: 30)
# Increase for long-running requests (file uploads, exports, etc.)
# IMPORTANT: For graceful shutdown, Docker's stop_grace_period (60s) should be > PUMA_WORKER_TIMEOUT
#            to allow all requests to complete before forced termination
# PUMA_WORKER_TIMEOUT=30

# Performance Guidelines (with ActionCable WebSocket support):
# - 1 CPU core:  WEB_CONCURRENCY=0, RAILS_MAX_THREADS=16  (16 concurrent connections)
# - 2 CPU cores: WEB_CONCURRENCY=2, RAILS_MAX_THREADS=16  (32 concurrent connections)
# - 4 CPU cores: WEB_CONCURRENCY=4, RAILS_MAX_THREADS=16  (64 concurrent connections)
# - 8 CPU cores: WEB_CONCURRENCY=8, RAILS_MAX_THREADS=32  (256 concurrent connections)
#
# Note:
# - Each WebSocket connection occupies 1 thread for its lifetime
# - Balance threads between REST API requests and WebSocket connections
# - Ensure DATABASE_POOL ≥ WEB_CONCURRENCY × RAILS_MAX_THREADS

# ============================================================================
# Database Configuration
# ============================================================================

# Option 1: Use individual variables (recommended with Docker secrets)
# DATABASE_HOST=pg
# DATABASE_PORT=5432
# DATABASE_NAME=app_production
# DATABASE_USER=postgres
# DATABASE_PASSWORD_FILE=/run/secrets/database_password

# Option 2: Use DATABASE_URL (traditional approach)
# DATABASE_URL=postgresql://postgres:password@pg:5432/app_production

# Database preparation on startup (default: false)
# Set to true only when needed: first deploy, migrations, schema changes
# RAILS_DB_PREPARE=true

# ============================================================================
# Redis Configuration (Multiple Instances)
# ============================================================================

# This template uses three separate Redis instances with different configurations:
# 1. redis_cache:   Rails.cache, rate limiting (LRU eviction, no persistence)
# 2. redis_cable:   ActionCable WebSocket pub/sub (no eviction, no persistence)
# 3. redis_session: Access tokens, user sessions (no eviction, AOF persistence)

# --- Redis Cache (Rails.cache, Rack::Attack, temporary data) ---
# Policy: allkeys-lru (can evict old data to make room)
# Persistence: No (cache can be rebuilt)
# Memory: 1GB
# REDIS_CACHE_HOST=redis_cache
# REDIS_CACHE_PORT=6379
# REDIS_CACHE_PASSWORD_FILE=/run/secrets/redis_cache_password

# Alternative: use URL format
# REDIS_CACHE_URL=redis://:password@redis_cache:6379/0

# --- Redis Cable (ActionCable WebSocket pub/sub) ---
# Policy: noeviction (pub/sub messages cannot be evicted)
# Persistence: No (real-time data, no need to persist)
# Memory: 512MB
# REDIS_CABLE_HOST=redis_cable
# REDIS_CABLE_PORT=6379
# REDIS_CABLE_PASSWORD_FILE=/run/secrets/redis_cable_password

# Alternative: use URL format
# REDIS_CABLE_URL=redis://:password@redis_cable:6379/0

# --- Redis Session (Access tokens, user sessions, important state) ---
# Policy: noeviction (important data cannot be evicted)
# Persistence: Yes (AOF for durability)
# Memory: 512MB
# REDIS_SESSION_HOST=redis_session
# REDIS_SESSION_PORT=6379
# REDIS_SESSION_PASSWORD_FILE=/run/secrets/redis_session_password

# Alternative: use URL format
# REDIS_SESSION_URL=redis://:password@redis_session:6379/0

# Why multiple Redis instances?
# - Different eviction policies (cache can evict, sessions cannot)
# - Different persistence needs (cache ephemeral, sessions durable)
# - Fault isolation (cache failure doesn't affect sessions)
# - Independent scaling (scale cache vs sessions separately)
# See docs/REDIS_ARCHITECTURE.md for details

# ============================================================================
# ActionCable WebSocket Configuration
# ============================================================================

# WebSocket URL for ActionCable
# Development: ws://localhost:3000/cable
# Production: wss://yourdomain.com/cable (use secure WebSocket)
# ACTION_CABLE_URL=ws://localhost:3000/cable

# Allowed origins for WebSocket connections (comma-separated)
# Security: Set to your frontend domain(s) in production
# Example: https://app.example.com,https://admin.example.com
# ACTION_CABLE_ALLOWED_ORIGINS=*

# Disable CSRF protection for ActionCable (default: true for API mode)
# Set to false if you need CSRF protection
# ACTION_CABLE_DISABLE_FORGERY_PROTECTION=true

# Scaling Guidelines for WebSocket connections:
# - < 100 concurrent users:    Single server (WEB_CONCURRENCY=2, THREADS=16)
# - 100-1000 concurrent users: Multiple servers + Redis adapter
# - 1000+ concurrent users:    Consider AnyCable or external service (Pusher, Ably)

# ============================================================================
# Secret File Paths (Container Runtime)
# ============================================================================

# These paths are where the application reads secrets inside the container
# Defaults are set in compose.yaml for Docker deployment
# Override these if using different orchestrator (Kubernetes, Nomad, etc.)

# Example: Kubernetes secrets (often mounted at /etc/secrets/)
# DATABASE_PASSWORD_FILE=/etc/secrets/db-password
# REDIS_PASSWORD_FILE=/etc/secrets/cache-password
# SECRET_KEY_BASE_FILE=/etc/secrets/app-secret

# Example: HashiCorp Vault
# DATABASE_PASSWORD_FILE=/vault/secrets/db_password
# REDIS_PASSWORD_FILE=/vault/secrets/cache_password

# Note: For Docker Compose, these are already configured in compose.yaml
# Only override if you know what you're doing

# ============================================================================
# Example Configurations
# ============================================================================

# Development/Staging with different database
# DATABASE_NAME=app_staging
# RAILS_ENV=staging

# Custom Redis database for testing
# REDIS_DB=1

# Use external managed database
# DATABASE_HOST=my-db.rds.amazonaws.com
# DATABASE_PORT=5432
# DATABASE_NAME=production_db
